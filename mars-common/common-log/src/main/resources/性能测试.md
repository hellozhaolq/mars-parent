# 测试代码

```java
public class Test {
    public static void main(String[] args) {
        long start = System.nanoTime();
        String msg = "打印日志";
        for (int i = 0; i < 10000; i++) {
            log.error(msg + i);
            log.warn(msg + i);
            log.info(msg + i);
            log.debug(msg + i);
            log.trace(msg + i);
        }
        long time = System.nanoTime() - start;
        log.info(String.valueOf(time));
        System.out.println(time);
    }
}
```

# logback

|                    | 同步   | 异步   |          |
| ------------------ | ------ | ------ | -------- |
| **打开控制台输出** | 5.03 s | 0.53 s | 提升10倍 |
| **关闭控制台输出** | 4.50 s | 0.26 s | 提升17倍 |

# log4j2

|                    | 同步   | 异步   |          |
| ------------------ | ------ | ------ | -------- |
| **打开控制台输出** | 2.00 s | 0.02 s | 提升100倍 |
| **关闭控制台输出** | 1.56 s | 0.02 s | 提升78倍 |

# 最后

记录"文件名"和"行号"的代价是非常昂贵的。针对上述测试而言，如果同步输出不记录它们，那么性能与异步相近(或略胜一筹或略低一筹)。但这并不意味着同步打印日志是可取的。

<font color="red">由于异步输出引入队列(内存)，因此面对高并发情况会远优与同步输出。</font> 

# 异步日志丢失问题
在执行Test.java时，有时最后输出并不是time或第10000条日志，那是因为队列中的日志还没有消耗完，代码已经执行完，jvm关闭所致。

方案一：在结尾处添加代码如下
```java
Scanner input = new Scanner(System.in);
String str = input.nextLine();
```
方案二：利用web接口测试
